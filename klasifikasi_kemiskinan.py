# -*- coding: utf-8 -*-
"""Klasifikasi_kemiskinan.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fToY1wr24mhK2ePWOrCLqrYgSClwbmi1

# Import Library
"""

# Commented out IPython magic to ensure Python compatibility.
# Pustaka untuk mengolah dan visualisasi data
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

# Pustaka keperluan model
from imblearn.over_sampling import SMOTE
from collections import Counter
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler, RobustScaler, MinMaxScaler
from sklearn.decomposition import PCA
from sklearn.neighbors import KNeighborsClassifier
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, f1_score, mean_squared_error, confusion_matrix, classification_report

# Mengabaikan peringatan
import warnings
warnings.filterwarnings('ignore')

"""# Data Loading"""

# Load dataset
df = pd.read_csv('https://raw.githubusercontent.com/elvinojunior/dicoding_ML_terapan1/refs/heads/main/Klasifikasi%20Kemiskinan%20di%20Indonesia.csv', sep=";")
df

"""# EDA (Exploratory Data Analysis)"""

# Ringkasan dataframe
df.info()

"""Ringkasan Dataframe :
* Memiliki 7 kolom dengan 514 baris data
* Beberapa kolom memiliki tipe data yang belum sesuai yaitu kolom : Persentase Penduduk Miskin (P0) Menurut Kabupaten/Kota (Persen), Indeks Pembangunan Manusia, dan Tingkat Pengangguran Terbuka
"""

# Mengganti nama kolom agar lebih mudah untuk melakukan EDA
df = df.rename(columns={
    'Provinsi': 'provinsi',
    'Kab/Kota': 'kab/kota',
    'Persentase Penduduk Miskin (P0) Menurut Kabupaten/Kota (Persen)': 'persen_kemiskinan_kota',
    'Pengeluaran per Kapita Disesuaikan (Ribu Rupiah/Orang/Tahun)': 'pengeluaran_kapita(ribu/tahun)',
    'Indeks Pembangunan Manusia': 'IPM',
    'Tingkat Pengangguran Terbuka': 'tingkat_pengangguran',
    'Klasifikasi Kemiskinan': 'klasifikasi_kemiskinan'
    })

"""Untuk Memudahkan dalam melakukan Data cleaning dan EDA saya mengganti beberapa nama kolom agar jadi lebih ringkas"""

# Mengubah tipe data object menjadi float
df['persen_kemiskinan_kota'] = df['persen_kemiskinan_kota'].str.replace(',', '.').astype(float)
df['IPM'] = df['IPM'].str.replace(',', '.').astype(float)
df['tingkat_pengangguran'] = df['tingkat_pengangguran'].str.replace(',', '.').astype(float)

df.info()

"""* Nama kolom sudah berubah menjadi lebih ringkas
* Tipe data sudah diubah menjadi lebih sesuai

## Data Cleaning
"""

# Cek missing values
df.isna().sum()

# Cek duplicated values
print(f"duplicated values : {df.duplicated().sum()}")

# # Menghapus missing values dan duplicated values
# df.dropna(inplace=True)
# df.drop_duplicates(inplace=True)

# # Melihat hasil setelah menghapus
# df.info()

"""Berdasarkan pengecekan missing values dan duplicated values tidak terlihat adanya missing values dan duplicated values jadi tidak perlu penanganan lebih lanjut. mari kita lanjut ke tahap pengecekan outlier"""

# Cek Outliers pada fitur numerik
outlier = df.drop(columns=['provinsi', 'kab/kota', 'klasifikasi_kemiskinan'])

# Plot boxplot tiap kolom
for column in outlier:
    plt.figure(figsize=(12, 6))
    sns.boxplot(x=outlier[column])
    plt.title(f'Boxplot {column}')
    plt.show()

"""Berdasarkan Boxplot pada kolom numerik terdapat beberapa outlier yang perlu ditangani"""

# Menangani outliers menggunakan IQR Method
Q1 = outlier.quantile(0.25)
Q3 = outlier.quantile(0.75)
IQR = Q3-Q1

df = df[~((outlier<(Q1-1.5*IQR))|(outlier>(Q3+1.5*IQR))).any(axis=1)]

"""Saya Menggunakan Metode IQR (Interquartile Range) yaitu teknik statistik yang digunakan untuk mengukur sebaran data dengan menghitung selisih antara kuartil ketiga (Q3) dan kuartil pertama (Q1). IQR membantu dalam mendeteksi outlier dengan menentukan batas bawah dan batas atas data yang dianggap normal.

Berikut langkah langkah nya :
1. Hitung Q1 dan Q3:

  Q1 dapat dihitung dengan menggunakan fungsi kuantil pada data.

  Q3 juga dihitung dengan cara yang sama.
2. Hitung IQR:

  IQR = Q3 - Q1.
3. Tentukan Batas Outlier:

  Batas bawah: Q1 - 1.5 * IQR.
  
  Batas atas: Q3 + 1.5 * IQR.
"""

# Ukuran data setelah penanganan outlier
print(f"ukuran data : {df.shape}")

# Statistik deskriptif
df.describe()

"""Setelah melakukan Penanganan outlier dataset kita menjadi 449 baris data dan 7 kolom.

Untuk insight dari statistik deskriptif :
* Sebagian besar daerah punya angka kemiskinan di bawah 14%, tapi ada beberapa daerah dengan kemiskinan sangat tinggi sampai 26.5%.

* Pengeluaran kapita masyarakat sangat bervariasi antar daerah, dari 5.78 juta sampai 16 juta per tahun.

* IPM rata-rata daerah di Indonesia masih sekitar 70, dengan gap cukup besar antara daerah terendah (58.7) dan tertinggi (82.6).

* Tingkat pengangguran di beberapa daerah sampai 11%, menunjukkan ketimpangan lapangan kerja antar wilayah.

* Data target klasifikasi kemiskinan sangat tidak seimbang (6.45% miskin vs 93.55% bukan miskin), perlu penanganan khusus di model training (misal: oversampling SMOTE, undersampling, atau class weight adjustment).

## UniVariate
"""

# Plot distribusi histogram untuk semua fitur numerik
num_cols = df.select_dtypes(include='number').columns

plt.figure(figsize=(18, 16))
for i, col in enumerate(num_cols):
    plt.subplot(4, 3, i+1)
    sns.histplot(df[col], kde=True, color='skyblue')
    plt.title(f'Distribusi {col}')
plt.tight_layout()
plt.show()

"""* Distribusi persen_kemiskinan_kota: Distribusi ini terlihat sedikit miring ke kanan (positively skewed). Ini mengindikasikan bahwa sebagian besar kota memiliki persentase kemiskinan yang relatif rendah, namun ada beberapa kota dengan persentase kemiskinan yang cukup tinggi yang menarik ekor distribusi ke kanan.

* Distribusi pengeluaran_kapita(ribu/tahun): Distribusi pengeluaran per kapita ini tampak mendekati distribusi normal atau sedikit miring ke kiri (negatively skewed). Ini menunjukkan bahwa sebagian besar populasi memiliki tingkat pengeluaran yang berada di sekitar nilai tengah, dengan beberapa orang memiliki tingkat pengeluaran yang lebih rendah.

* Distribusi IPM: Indeks Pembangunan Manusia (IPM) menunjukkan distribusi yang cenderung simetris atau mendekati normal. Ini menandakan bahwa sebagian besar wilayah memiliki tingkat pembangunan manusia yang serupa, dengan variasi yang tidak terlalu ekstrem.

* Distribusi tingkat_pengangguran: Distribusi tingkat pengangguran juga terlihat miring ke kanan (positively skewed). Ini berarti sebagian besar wilayah memiliki tingkat pengangguran yang relatif rendah, tetapi ada beberapa wilayah dengan tingkat pengangguran yang lebih tinggi yang menyebabkan ekor distribusi memanjang ke kanan.

* Distribusi klasifikasi_kemiskinan: Terlihat bahwa sebagian besar individu terklasifikasi sebagai tidak miskin (nilai 0), dengan sedikit yang terklasifikasi miskin (nilai 1).
"""

# Distribusi data pada kolom provinsi
plt.figure(figsize=(16, 10))
sns.countplot(x=df['provinsi'],  data=df)
plt.xticks(rotation=45, ha='right')
plt.title('Distribusi kemiskinan pada provinsi')
plt.ylabel('Jumlah')
plt.show()

"""Distribusi data pada kolom provinsi :
*   Data dengan sedikit kontribusi ada di provinsi DKI Jakarta
*   Kontibusi data paling banyak ada di provinsi Jawa Timur



"""

# Banyaknya nama kabupaten/kota yang ada didalam data
df['kab/kota'].nunique()

"""Data mencakup 449 kabupaten/kota, visualisasi grafiknya tidak saya sertakan karna grafik yang terlalu banyak sulit untuk mata kita meng-interpretasikan/memahami nya

## MultiVariate
"""

# data kemiskinan pada kolom provinsi
plt.figure(figsize=(16, 10))
sns.countplot(x=df['provinsi'], hue=df['klasifikasi_kemiskinan'],  data=df)
plt.xticks(rotation=45, ha='right')
plt.title('Status kemiskinan pada provinsi')
plt.ylabel('Jumlah')
plt.show()

"""* Variasi Pola Kemiskinan Antar Provinsi: Pola distribusi antara kategori "0" dan "1" sangat bervariasi antar provinsi. Ada provinsi di mana jumlah yang tidak miskin jauh lebih banyak dari yang miskin, ada yang perbedaannya tidak terlalu besar, dan bahkan ada beberapa provinsi (meskipun terlihat sedikit) di mana jumlah yang diklasifikasikan sebagai miskin hampir sebanding atau bahkan lebih banyak dari yang tidak miskin.

* Insight : Beberapa provinsi terlihat memiliki batang kategori "0" yang jauh lebih tinggi daripada batang kategori "1", mengindikasikan proporsi "kemiskinan" yang relatif rendah.

* Contoh Provinsi Spesifik:

  1. Aceh: Terlihat memiliki jumlah kategori 0 yang lebih tinggi dari kategori 1.
  2. Papua: Menarik untuk diperhatikan bahwa di Papua, jumlah kategori 1 (miskin) terlihat lebih tinggi dibandingkan kategori 0 (tidak miskin).
  3. Nusa tenggara timur & Maluku: memiliki jumlah kategori 0 (tidak miskin) dan kategori 1 (miskin) yang hampir sama
"""

# Mengamati hubungan antar fitur numerik dengan fungsi pairplot()
sns.pairplot(df, diag_kind = 'kde')

# Heatmap korelasi fitur numerik
plt.figure(figsize=(12, 10))
sns.heatmap(df[num_cols].corr(), annot=True, cmap='coolwarm')
plt.title('Heatmap Korelasi Antar Fitur Numerik')
plt.show()

"""Heatmap ini menunjukkan hubungan linear antar fitur numerik dalam dataset, termasuk terhadap target klasifikasi_kemiskinan. Nilai korelasi berkisar antara -1 sampai 1:

*   1 =  hubungan positif sempurna

* -1 = hubungan negatif sempurna

*  0 = tidak ada hubungan linear

| Pasangan Fitur                                          | Korelasi   | Interpretasi                                                                                                                                                         |
| :------------------------------------------------------ | :--------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **persen\_kemiskinan\_kota & klasifikasi\_kemiskinan**  | **+0.57**  | Cukup kuat positif. Artinya semakin tinggi persentase kemiskinan di kota, kemungkinan masuk ke klasifikasi miskin juga meningkat.                                    |
| **pengeluaran\_per\_kapita & IPM**                      | **+0.85**  | Sangat kuat positif. Semakin tinggi pengeluaran per kapita, biasanya IPM (Indeks Pembangunan Manusia) juga ikut tinggi. Masuk akal karena IPM terkait kesejahteraan. |
| **pengeluaran\_per\_kapita & klasifikasi\_kemiskinan**  | **-0.29**  | Lemah negatif. Semakin tinggi pengeluaran per kapita, peluang masuk klasifikasi miskin sedikit menurun.                                                              |
| **IPM & klasifikasi\_kemiskinan**                       | **-0.27**  | Lemah negatif. Semakin tinggi IPM, peluang masuk klasifikasi miskin juga cenderung lebih rendah.                                                                     |
| **tingkat\_pengangguran & klasifikasi\_kemiskinan**     | **-0.035** | Sangat lemah negatif. Tidak signifikan. Artinya tingkat pengangguran hampir tidak punya pengaruh langsung terhadap klasifikasi kemiskinan di data ini.               |
| **persen\_kemiskinan\_kota & pengeluaran\_per\_kapita** | **-0.52**  | Cukup kuat negatif. Semakin banyak orang miskin di kota, pengeluaran per kapitanya cenderung lebih rendah.                                                           |

# Data Preparation
"""

# One hot encoding provinsi
df = pd.get_dummies(df, columns=['provinsi'])

"""Melakukan teknik One-hot encoding pada kolom provinsi"""

# Menghapus kolom provinsi dan kab/kota
df.drop(columns=['kab/kota'], inplace=True)
df.columns

"""Menghapus kolom kab/kota karna ingin merepresentasikan kemiskinan secara provinsi"""

# Pisahkan kolom target klasifikasi
X = df.drop(columns=['klasifikasi_kemiskinan'])
y = df['klasifikasi_kemiskinan']

# Split data train dan test dengan rasio 80:20
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42, stratify=y)

"""Melakukan teknik split data yaitu train dan test dengan rasio 80:20"""

# Normalisasi menggunakan standard scaler
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""Melakukan normalisasi dengan menggunakan metode standard scaler agar data yang digunakan tidak memiliki penyimpangan yang besar.


![image.png](data:image/png;base64,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sGTJEmbPnq3dDTULtI8dO7ZFDnPStE9nyMTVvRCPiyay5FhmUmxeAH9qsFNH9uko4o6c4wwOGOhHwGB/One0wrfxC22Iv+DCBJUXX3wRV1dXvvjiC+OKLJebVp+Tk0NaWhrAFVeCKC0tZfbs2cap5N26deP111+HmtUh7Ozs+Oabb0hKSmL69Om1ppxXVlYSFxdHaWkpU6ZMoWvXrg1eveWvcHV15auvvuLf//43Bw4cYOPGjUyseczRBenp6Vcc4pw6dSoGg4E33niD9PR0nn/++TrX+S48qqhfv3488MADzJkzp0Grt1zJwIEDWbhwIXPmzCEnJ4ePPvqI9evX16o5ffo0eXl5tfZdDcnJyUyZMqXBK+fs3r2bvLw8hg8fzuOPPw41w7X1mT17NhYWFnz44YfGx+DMmzePH3/8sVbdiRMnSE1NJTAwkEWLFtG3b99LDtfZ29sbH+h64TFPTk5ODVodpj7jx4+nvLycZ555hqysLObOncuSJUtq1Rw9epTU1FQ6derEggULmDNnzhVXb7mwju6Fe/7CwsIuudyalp2dHZ999hmRkZHs3LmTbdu21fmdpuY1oqKiKCsr49Zbb215M0+1XcBrJ1ul7P9IvTWrl3Go855PflW70+oOnTRI9h61MfIuNbmtt7K07ap8enyo3tn8hzpTz3CFaDp79+5VkZGR6sUXX1QeHh61hl+0W9u2bVVkZKSKjIxUJ06c0J5KqZoHXd577711jh0+fHitut27d6t77rmnTt3F2+233662bNmi4uPj1bPPPqtatWqlJk+eXGfV+6s11HnBd999pyIjI40P2714Cw0NNf4MgoODFfUMdSqlVFRUlJozZ45ycHCoc44L24033qi+//57lZ+fr95++20VGBioevfurX744Yda52rMUKdSSuXm5qq5c+eqyMhI1b9//zqvO2rUKBUZGakeffRR41MhrsZQZ2O3GTNmqMjISPXzzz9rT1mvI0eOGH/2F4ak69t69uypPvvsM2UwXPlpLzqdTr388suqdevWasKECWrt2rXakjouNdSplFLnzp1TL730kvLy8qrzdV3Y+vTpoxYtWqT0er36+OOPVffu3VWbNm3UokWLap1r79696v77769z/ODBg2vVXW6o84Iff/xRRUZG1vveBJStra169NFHVWRkpNq8ebP2cKWaeajTIjKynocpXRP26HNySDgVy459Z9DjSe8h4wjv2A6/Vo3peBqAQs7sWM13K7aw6kgBFgH9GHb/fTw8vD3B7vV/GhNNw8/Pj6FDhzJgwACSk5Np3bo1oaGh9W7Dhw/ntddeY+jQoXh7e2tPBYC/vz+BgYGkpKTUOrZXr1617ssLCAigQ4cO6HS6Oq9zYXvqqacYMmQIbm5u9O3bl3PnzlFUVERAQECtWX8JCQnY29sTERHB0KFDjfvrk56eTkVFBWFhYYwbN67e3kDXrl0ZOnQoAQEBpKen1/qabrrpJv7zn/8wdOhQ8vLycHJyonfv3gwePLjWOTw8POjVqxdJSUm0bdu2zvcWGhrK9OnTueOOO7C1tWXAgAHk5ORQVFSEg4NDrWfy6XQ6qqur6dq1K2PHjr3sGpzUfMofOHAgQ4cOxdzcHIPBUOt1Z86cyezZs+nWrRtJSUl06NCB4cOHX7K3dSUXhqq139+VtpdffpkpU6Y0+HVbt27N0KFDGTp0KDqdDg8PjzrnDA0NZcqUKTz88MMNWgLRycmJIUOGoNPpmDp1KjfddJO2pI6kpCQsLS3p0aNHnRvcXVxcjMP33t7edb620NBQ7rjjDh544AHMzc2JiIigrKyMiooKzMzMGDlypPFcfn5+BAUFkZycXOv4Xr16MWLECGNdZmYmJSUldOrUiYkTJ9Y7atO5c2eGDh1a73szNDSUbt268cYbbzB+/PhL3sZx4YHIoaGhjBkz5rI331dVVREbG4ufnx+DBw+ud5ZuY5ipqzGXt6HSD7Fj2Ve88OI3HChvx/DH/8Vj941kbCNWblGGUqqKDvLG7Af49Pt4Mn27EjDsHyz//Gm62FnT8teGF0II0ZyacHIL4OlFWN+OPDSyDTZmsZylhCtf0q+tMjeX+LmRLFsdTyaB9L75Phb/36N0t7W6KtPzhRBCXN+aNvgsvLAI6IP36BsZbtBTuHwfe48kclxbdwlpcUf48f+e4da3txNbFspNzz3Gi49OoYebEzZmZlx5IEIIIYSpa9rgwxZbt2A6DLmFm6f0wyP1LKd+O8COwwlkXli/s145pJzeyobvviXytQ1EBQxk3L+fYMad4xnUMQAnkNATQgjRIE04ueU8Kys7nBw9cfOxpiIvjT1bjlFYpQcPV1rZW6IqK7EwM0OpCgoKdGRlpRBzZDu716xi+erfOWg3ivsfnsHD02+iX7Dvn7oRQgghhOlq2sktGglbP2fp/I/4eN1ZMobcz9xXJhJWWUV7bx9sHas4k7iO+PgkVsxeRDo96DDtPvrdehPPjg3ExqqJO6tCCCGuC80afFXlJVQmniU1OYqT1VFsWLuCM9+c5EApFAUFEjpyBM7tWvNk6BR6hLTBw8cSa1tbHG0tacDMYiGEEKKOZg0+AMrL0VcUUaAvJD09jcK0IorLq1AODjh6eeHo6IiPkw+tHG25wu1GQgghxBU1f/AJIYQQTUgulAkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqRI8AkhhDApEnxCCCFMigSfEEIIkyLBJ4QQwqT8P//GnKLLJxJDAAAAAElFTkSuQmCC)

Metode ini bekerja dengan cara menghitung rata-rata dan standar deviasi dari data, kemudian membagi setiap nilai data dengan standar deviasi tersebut.
"""

# Oversampling SMOTE agar data target balance
# Cek distribusi sebelum SMOTE
print("Distribusi sebelum SMOTE:", Counter(y_train))

# SMOTE
smote = SMOTE(random_state=42)
X_train_smote, y_train_smote = smote.fit_resample(X_train_scaled, y_train)

# Cek distribusi setelah SMOTE
print("Distribusi setelah SMOTE:", Counter(y_train_smote))

"""Untuk penanganan imbalance class saya menggunakan teknik Oversampling SMOTE pada data train saya.

Oversampling SMOTE yaitu kondisi di mana jumlah sampel pada satu kelas (kelas minoritas) jauh lebih sedikit dibandingkan dengan kelas lainnya (kelas mayoritas). Tujuan SMOTE adalah untuk menyeimbangkan distribusi kelas dengan cara menciptakan sampel sintetis baru untuk kelas minoritas, bukan hanya menggandakan sampel yang sudah ada.

Cara kerja Oversampling SMOTE itu seperti ini:

1. Cari Kelereng Biru yang Mirip: Untuk setiap kelereng biru yang kamu punya, SMOTE akan mencari beberapa kelereng biru lain yang paling mirip dengannya (misalnya, ukurannya hampir sama).

2. Bikin Kelereng Biru "Bayangan": SMOTE tidak menggandakan kelereng biru yang sudah ada. Tapi, ia akan membuat kelereng biru "bayangan" yang posisinya ada di antara kelereng biru asli dan kelereng biru mirip yang ditemukannya. Anggap saja seperti mencampur warna antara dua kelereng biru untuk mendapatkan warna biru yang sedikit berbeda.

3. Tambah Kelereng Bayangan: Kelereng biru "bayangan" ini adalah data baru yang mirip dengan data yang sudah ada, tapi tidak persis sama. Dengan menambahkan kelereng biru "bayangan" ini, jumlah kelereng biru jadi lebih banyak dan lebih seimbang dengan kelereng merah.

# Model Development
"""

# Siapkan dataframe untuk menyimpan performa model
models = pd.DataFrame(index=['train_mse', 'test_mse', 'akurasi', 'f1_score'],
                      columns=['KNN', 'DecisionTree', 'RandomForest'], dtype='float')

"""## K-Nearest Neighbour"""

# train model KNN
knn = KNeighborsClassifier(n_neighbors=5)
knn.fit(X_train_smote, y_train_smote)

y_train_pred_knn = knn.predict(X_train_smote)
y_test_pred_knn  = knn.predict(X_test_scaled)

# MSE dan accuracy score model
train_mse_knn = mean_squared_error(y_train_smote, y_train_pred_knn)
test_mse_knn  = mean_squared_error(y_test, y_test_pred_knn)
accuracy_knn  = accuracy_score(y_test, y_test_pred_knn)
f1_score_knn  = f1_score(y_test, y_test_pred_knn, average='weighted')

# Simpan ke dataframe
models.loc['train_mse', 'KNN'] = train_mse_knn
models.loc['test_mse', 'KNN']  = test_mse_knn
models.loc['akurasi', 'KNN']   = accuracy_knn
models.loc['f1_score', 'KNN'] = f1_score_knn

"""Model pertama yang saya pilih yaitu algoritma KNN yang mengklasifikasikan atau memprediksi label dari sebuah data baru berdasarkan label dari K data terdekatnya dalam ruang fitur. Kedekatan biasanya diukur menggunakan jarak (misalnya, Euclidean).

Cara Kerja:

1. Tentukan K: Pilih jumlah tetangga terdekat (K) yang ingin dipertimbangkan. Nilai K adalah bilangan bulat positif (disini saya memilih 5).

2. Hitung Jarak: Hitung jarak antara data baru yang ingin diklasifikasikan/diprediksi dengan semua data yang ada dalam dataset pelatihan.

3. Cari K Tetangga Terdekat: Pilih K data dalam dataset pelatihan yang memiliki jarak terkecil dengan data baru.

4. Klasifikasi: Hitung jumlah kelas yang paling sering muncul di antara K tetangga terdekat.
Label kelas yang paling sering muncul inilah yang diprediksi menjadi label untuk data baru.

## Decision Tree
"""

# train model Decision Tree
dtree = DecisionTreeClassifier(random_state=42, max_depth=3)
dtree.fit(X_train_smote, y_train_smote)

y_train_pred_dt = dtree.predict(X_train_smote)
y_test_pred_dt  = dtree.predict(X_test_scaled)

# MSE dan accuracy score model
train_mse_dt = mean_squared_error(y_train_smote, y_train_pred_dt)
test_mse_dt  = mean_squared_error(y_test, y_test_pred_dt)
accuracy_dt  = accuracy_score(y_test, y_test_pred_dt)
f1_score_dt  = f1_score(y_test, y_test_pred_dt, average='weighted')

# Simpan ke dataframe
models.loc['train_mse', 'DecisionTree'] = train_mse_dt
models.loc['test_mse', 'DecisionTree']  = test_mse_dt
models.loc['akurasi', 'DecisionTree']   = accuracy_dt
models.loc['f1_score', 'DecisionTree']  = f1_score_dt

"""Selanjutnya saya menggunakan Decision tree yaitu algoritma supervised learning yang digunakan untuk klasifikasi dan regresi. Cara kerjanya adalah dengan membuat struktur seperti pohon di mana setiap node internal merepresentasikan sebuah fitur (atau atribut), setiap cabang merepresentasikan sebuah keputusan atau aturan pengujian, dan setiap leaf node (node daun) merepresentasikan hasil akhir (kelas atau nilai prediksi).

Tujuan utama dari Decision Tree adalah untuk membuat serangkaian aturan keputusan sederhana ("jika-maka") yang dapat digunakan untuk memprediksi kelas atau nilai dari data baru.

## Random Forest
"""

# train model Random Forest
rf = RandomForestClassifier(random_state=42, max_depth=3)
rf.fit(X_train_smote, y_train_smote)

y_train_pred_rf = rf.predict(X_train_smote)
y_test_pred_rf  = rf.predict(X_test_scaled)

# MSE dan accuracy score model
train_mse_rf = mean_squared_error(y_train_smote, y_train_pred_rf)
test_mse_rf  = mean_squared_error(y_test, y_test_pred_rf)
accuracy_rf  = accuracy_score(y_test, y_test_pred_rf)
f1_score_rf  = f1_score(y_test, y_test_pred_rf, average='weighted')

# Simpan ke dataframe
models.loc['train_mse', 'RandomForest'] = train_mse_rf
models.loc['test_mse', 'RandomForest']  = test_mse_rf
models.loc['akurasi', 'RandomForest']   = accuracy_rf
models.loc['f1_score', 'RandomForest']  = f1_score_rf

"""dan terakhir saya menggunakan algoritma Random Forest yaitu algoritma supervised learning yang termasuk dalam kategori ensemble learning. Artinya, alih-alih menggunakan satu model, Random Forest membangun banyak Decision Tree (pohon keputusan) secara independen dan kemudian menggabungkan prediksi dari semua pohon tersebut untuk mendapatkan prediksi akhir. Ide utamanya adalah bahwa "kerumunan" pohon yang lemah dapat menjadi "hutan" yang kuat dan akurat.

# Evaluasi Model
"""

print(models)

"""1. Decision Tree Unggul: Secara keseluruhan, Decision Tree menunjukkan performa terbaik pada dataset ini, terutama dalam meminimalkan nilai MSE serta F1-Score yang lebih tinggi. Akurasinya juga paling tinggi.

2. Random Forest Kompetitif: Random Forest juga menunjukkan performa yang sangat baik, hampir setara dengan Decision Tree, tetapi pada MSE, F1 Score dan akurasi sedikit lebih rendah.

3. KNN Kurang Baik: KNN memiliki akurasi yang cukup buruk dibanding model lainnya, terutama dalam hal test MSE, akurasi dan F1-Score.
"""

# Confusion matrix KNN
cm_knn = confusion_matrix(y_test, y_test_pred_knn)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_knn, annot=True, fmt='d', cmap='Blues',
            xticklabels=knn.classes_, yticklabels=knn.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix KNN')
plt.show()

# Confussion matrix Decision tree
cm_dt = confusion_matrix(y_test, y_test_pred_dt)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_dt, annot=True, fmt='d', cmap='Blues',
            xticklabels=dtree.classes_, yticklabels=dtree.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Decision Tree')
plt.show()

# Confussion matrix Random forest
cm_rf = confusion_matrix(y_test, y_test_pred_rf)

# Visualisasi confusion matrix
plt.figure(figsize=(8,6))
sns.heatmap(cm_rf, annot=True, fmt='d', cmap='Blues',
            xticklabels=rf.classes_, yticklabels=rf.classes_)
plt.xlabel('Predicted')
plt.ylabel('Actual')
plt.title('Confusion Matrix Random Forest')
plt.show()

"""Kesimpulan Keseluruhan:

1. Decision Tree dan Random Forest menunjukkan performa yang lebih baik secara keseluruhan dibandingkan dengan KNN dalam tugas klasifikasi ini pada data testing. Keduanya sangat baik dalam mengidentifikasi instance positif (kelas 1) dengan recall sempurna.
2. Decision Tree memiliki keunggulan sedikit dalam hal False Positive, yang menghasilkan presisi yang sedikit lebih baik untuk kelas 0 dibandingkan Random Forest.
3. KNN memiliki performa yang paling rendah, dengan jumlah False Positive dan False Negative yang lebih tinggi dibandingkan dua model lainnya. Ini mengindikasikan bahwa KNN kurang efektif dalam memisahkan kedua kelas pada data testing.
4. Mengingat kelas 1 adalah kelas minoritas (hanya 6 sampel aktual), kemampuan Decision Tree dan Random Forest untuk mengklasifikasikannya dengan baik (recall tinggi dan jumlah FN=0) sangat signifikan.
5. Secara keseluruhan, berdasarkan confusion matrix, Decision Tree dan Random Forest adalah pilihan model yang lebih baik untuk tugas klasifikasi ini dibandingkan dengan KNN. Decision Tree menunjukkan performa yang sedikit lebih unggul dalam hal meminimalkan False Positive.
"""